이상훈님 발표

##### 발표 순서
##### 전통적 웹 방식
thread per request 방식 설명
플랫폼 스레드 : 플랫폼 스레드와 커널 스레드가 1:1 매핑되는 고조 자원이 한정되므로 무한정 스레드를 늘릴 수 없음
thread pool을 사용하여 thread를 재사용하는 방식으로 동시성을 처리 하는 방식이지만
최대 요청시 thread 개수로 제한되거나, 적정 스레드 수와 생성 문제 언급

전통적인 방식은 io 처리에 대한 겨로가를 받기 전까지 스레드 블로킹 발생
커널 스레드 사용 -> 무한정 생성 불가 -> 스레드 풀 사용
웹 서버 최대 처리량 스레ㅍ드 풀 생성된 스레드 수로 제한
비동기 논블로킹 방식으로 더 적은 스레드로 더 많은 일을 할 수 있지만 가독성과 유지보수가 어려움


##### 리액티브 프로그래밍
비동기 논블로킹의 문제가 되는 콜백헬을 함수형 프로그래밍 관점으로 해결
대표적 표준은 리액티브 스트림즈
비동기 데이터 스트림 논블로킹 백프레셔에 대한 사양 제공
prejcet reactor,
실시간 데이터 처리에 유연하게 개발 가능, 높은 트래픽 감당하는 시스템에서 유리했단 경험

reactive stream core interface, protocol
pub/sub

마블 다이어그램 이해

spring webflux사용시 블로킹 api를 래퍼로 감싸서 사용함
##### 코틀린 코루틴

코틀린 코루틴 > 확장 라이브러리 상호 운용성

코틀린 코루틴을 사용하여 전통적인 개발방식으로 개발 가능 , 리액티브 프로그래밍을 하더라도

코루틴은 매우 가볍다 > 스레드에 비해 가볍다
다수의 코루틴이 소수의 플랫폼 스레드에 매핑되어 동작
코루틴 N : N 플랫폼 스레드 1 : 1 커널 스레드

 delay 지정된 시간만큼 코루틴 대기
Thread.sleep과 차이점은 스레드가 블로킹이 되지 않음

다수의 동시성을 효율적으로 처리

스레드가 블로킹되는 환경에선 코루틴도 성능이 떨어질수밖에 없다 -> 이유는 코루틴은 플랫폼 스레드에 바인딩되기 때문

쿠틀린 코루틴은 비동기 논블로킹 환경에서 사용하는 것이 적절

코루틴 빌더 :
코루틴을 생성하는 함수

runBlocking: 감싸진 코드가 모두 수행될때까지 호출 스레드가 블로킹된다
테스트 코드 , 스프링 배치 같은 코루틴 지원하지 않는 환경에서 코루틴과 블로킹 스택을 연결해야하기 때문

launch: 스레드 블로킹 없이 새로운 코루틴을 시작하며 결과를 만들어 내지 않는 비동기 작업에 적합

async: 비동기 작업을 통해 결과를 만들어내는 경우 적절
비동기 작업의 결과로 deferred(interface)를 반환하는데 await함수를 통해 async로 수행한 비동기 작업의 결과를 받아올 수 있다.


구조적 동시성 : 코루틴 생명주기와 예측 가능성 향상
스레드 블로킹 없이 각 동시 작업의 수행이 완료된 후 함수가 종료된다
coroutineScope 예측가능하게 하기 쉬움

구조적 동시성에서 예외를 다루는 방법: 모든 코루틴 취소
coroutineScope: 내부 자식 코루틴에서 에러가 발생하면 모든 코루틴이 종료된다 > 트랜잭션 마냥 동작하네
빌더내부에서 try catch로 복구하거나
부모 코루틴 내부에 supervisorscope에서 처리하면 부모 코루틴으로 전파되지 않음

nocancellable context: 다른 코루틴에서 예외가 발생하더라도 작업이 수행된다

---

코루틴 컨텍스트: 코루틴이 실행되는 환경을 제어하는 방법

dispatchers : 코루틴이 실행되는 스레드를 결정, IO로 지정하면 IO작업에 최적화된 방식으로 처리된다
내부에 4개의 dispatcher가 있음
default, io, main , unconfined가 있음

ThreadLocal의 데이터를 코루틴에 전파하는 방법
MDC: multi thread환경에서 로깅을 위한 .. 방식  thread에 저장됨

코루틴용 slf4j 확장 추가해서 해결
MDCContrext가 있음
ThreadContextElement를 사용

코루틴 정리
비동기 작업을 동기 방식처럼 순차적 코드 작성
결자ㅑㅇ 스레드로 대규모 듕시성 작업 효율
구조적 동시성 계층 구조 명확히 정의 생명 주기 관리
코루틴 컨텍스트를 사용해 실행환경 제어
블로킹 환경에서 사용하면 성능 향상이 높지 않음
코루틴을 사용하는 측에서도 suspend를 선언해야한다



##### 버추얼 스레드 

project loom feat중 일부

java 플랫폼 위에 경량 동작 , 높은 처리량을 달성, 사용하기 쉬운 프로그래밍 모델

다수의 버추얼 스레드가 소수의 캐리어 스레드에 매핑되어 동작
버추얼 전용 스레드를 캐리어 스레드라함
특정 버추얼 스레드가 블로킹되면 다른 버추얼 스레드로 전환됨
버추얼 스레드 전환은 os가 아니라 jvm위에서 돌아가기때문에 성능저하가 더 적음

버추얼 스레드 생성방법
startVirtualThread()
ofVirtual()

내부에서 스레드를 블록킹하더라도 성능하락없이 스레드 전환이됨 - 코루틴과의 차이점

spring bean, yml로 버츄얼 스레드 사용 설정 가능

visual vm

버추얼 스레드
전통적인 동기식 코드 그대로 작성 가능 
jvm 레벨 경량 스레드로 적은 리소스로 대규모 동싷성 작업 효율적 지원
버추얼 스레드는 기존 스레드 api를 그대로 활용할 수 있도록 설계
web mbc + virtual thread는 webflux 코루틴과 거의 비슷한 성능
synchronized관련 piined 이슈 등 아직 성능을 100%로 내기 어려운 환경이 있어 리서치 필요
##### 코루틴과 버추얼 스레드 통합 방안

virtual thread

scoped value : 스레드간 데이터를 저장하고 공유한느 방법
버추얼 스레드를 코루틴 디스패쳐로 변환
runBlocking으로 감싸서 사용해도 버츄얼스레드라서 성능하락 없이 동기 방식 처리 가능

structured concurrency : 코루틴의 구조적 동시성 같은 목적
동시 작업의 결과를 만들어내야 하는 경우


sse 실시간 주식 시세 제공
sse 활용

코틀린 Flow 라이브 데이터 스트림 응답
스트리밍 api 구현시

flowOn을 사용해 버추얼 스레드 디스패쳐에서 수행하도록하여 블로킹io 성능하락 방지

정리
코루틴 담점이 블로킹 상황의 성능 하락 이슈를 버추얼 스레드가 해결
코루틴 버추얼 스레드 상호 운용을 통해 코루틴의 구조적 동시성과 코루틴 컨텍스ㄹ트를 그대로 활용
버추얼 스레드에서 지원하지 않는 기능 (스트리밍, 백프레셔)은 코루틴의 고급 라이브러리를 활용해 구현
기존 코루틴을 사용했던 애프릴케이션의 jdk버전을 올려 버추얼 스레드를 혼합 사용 가능