# 특징
- [[Lucene]]기반 오픈소스 검색엔진으로 JSON 기반의 문서를 저장하고 검색할 수 있으며 분석 작업이 가능하다.
- 준실시간 검색 시스템이다.(실시간이라고 생각될 만큼 색인된 데이터에가 빠르게 검색됨)
- 고가용성을 위한 클러스터 구성이 가능하다
	- 한 대 이상의 노드로 클러스터를 구성하여 높은 수준의 안전성을 달성하고 부하 분산이 가능
- 동적 스키마 생성
	- 입력될 데이터에 대해 미리 스키마 정의 없이 동적으로 생성이 가능
- Rest API 기반 인터페이스 제공하여 사용을 위한 진입장벽이 낮음

# 클러스터, 노드
## 클러스터 
ElasticSearch 클러스터는 여러대의 노드들이 각자의 역할을 바탕으로 연결되어 하나의 시스템처럼 동작하게 되어 있다.

클러스터 성능이 부족할시 노드를 늘려서 대응이 가능하지만 노드를 늘린다고해서 항상 성능이 늘어나는 것은 아니다.
> __이유__ : 색인 처리를 담당하는 노드가 1대만 있는 경우 색인데 대한 과정에 대해서는 클러스터 노드들 중에서 여전히 1대만 처리하고 있기 때문에 (데이터)노드만 늘린다고하여 성능이 향상되는 것은 아님 -> 적절한 수의 샤드 개수를 설정하는 것이 성능에 영향을 미친다.
## 노드 
### 마스터 노드
클러스터 상태 관리 및 메타데이터 관리
현재 클러스터에서 마스터 노드의 역할을 하고 있는 단 1개의 노드
### 마스터 후보 노드
마스터 노드에 문제가 생길시 대체될 노드
### 데이터 노드
문서 색인 및 검색 요청 처리
### 코디네이팅 노드
검색 요청 처리
### 인제스트 노드
색인되는 문서의 데이터 전처리(문서가 ES에 저장되기전에 특정 처리하는 행위)

### 노드간 요청 흐름
사용자가 마스터 노드에게 요청을 보낸다 -> 마스터 노드는 본인이 문서를 보유하고 있지 않기 때문에 데이터 노드에게 요청을 전달하여 처리를 요청함

클러스터로 동작하기 때문에 마스터 노드가 아니라 데이터 노드에게 요청을 보내도 동일한 결과를 받을 수 있다.

비슷한 개념으로 코디네이팅 노드에 검색 요청을 전달해도 내부적으로 데이터 노드를 호출하여 결과를 반환 받을 수 있다.

==하지만== 각 노드에게 직접적인 요청을 보내는 방식보다 api gateway를 지나처 로드밸런서를 통해 접근하는 방식으로 구성하는 것이 좋다.

# 인덱스, 샤드
| ElasticSearch | RDBMS    |
| ------------- | -------- |
| index         | database |
| mapping       | schema   |
| document      | row         |


==__index__==

문서가 저장되는 논리적인 공간
문서를 저장하기 위해 반드시 인덱스가 존재해야한다.

인덱스 설계가 가장 첫 번째로 고려해야하는 부분이다.
인덱스 설계에 따라 문서의 구조와 검색 쿼리가 달라진다.

#### 인덱스 설계 
| 케이스                    | 장점                                                       | 단점                                                        |
| ------------------------- | ---------------------------------------------------------- | ----------------------------------------------------------- |
| 하나의 인덱스를 사용할 때 | 관리해야 할 인덱스의 수가 적어 관리 리소스가 적게 발생한다 | 쿼리와 문서의 구조가 복잡해 질 수 있다.                     |
| 여러개의 인덱스로 나눌 때 | 각각의 경우에 최적화된 쿼리와 문서 구조를 사용 할 수 있다  | 관리해야 할 인덱스의 수가 많아 관리 리소스가 발생할 수 있다 |
|                           |                                                            |                                                             |


하나의 인덱스로 단순하게 시작해서 -> 사용 패턴에 따라 인덱스를 별도로 운영하는 방식으로 확장해 나아가는 것이 좋다.

==__shard__==

인덱스에 색인되는 문서가 저장되는 `공간`
> 하나의 인덱스는 반드시 하나 이상의 샤드를 가진다.

#### 샤드 종류
| 종류            | 역할                                                            |
| --------------- | --------------------------------------------------------------- |
| 프라이머리 샤드 | 문서가 저장되는 원본 샤드, 색인과 검색 성능에 모두 영향을 준다. |
| 레플리카 샤드   | 프라이머리 샤드의 복제 샤드, 검색 성능에 영향을 준다. 프라이머리 샤드에 문제가 생기면 레플리카 샤드가 프라이머리 샤드로 승격된다.                                                                |


문서가 -> 프라이머리 샤드 -> 레플리카 샤드로 저장되는 과정을 색인이라고 말할 수 있다.
프라이머리 샤드에서 문서를 분석하는 작업이 있어 자원 소모가 더 크다.

샤드는 인덱스 생성시 설정하게 되는데 프라이머리 샤드와 레플리카 샤드의 수를 설정할 수 있다.

#### 샤드 라우팅
문서가 샤드에 저장되는 방법, 순서를 의미

문서들은 샤드에 고르게 저장이 되는데 샤드의 개수에 변화가 생기면 문서가 저장되는 규칙이 바뀌게 된다. >> 그래서 인덱스의 프라이머리 샤드는 생성 후 변경 불가능 하다 

> Routing Rule = (문서의 ID) % (샤드의 개수)

최소 샤드 수 설정이 중요하다

#### 인덱스 템플릿
매번 인덱스에 할당할 샤드를 미리 만들고 문서를 넣는 작업은 불편하기 때문에 인덱스 템플릿을 만들고 템플릿 내에 인덱스 패턴으로서 등록을 해두는 방식을 사용한다.

``` json
{
	"index_patterns" : ["spring-logs-1"],
	"template" : {
		"setting" : {
			"number_of_shards" : 3,
			"number_of_replicas" : 2
		}
	}
}
```

# 매핑
매핑이란 문서의 구조를(동적 스키마) 나타내는 정보

#### 매핑 종류
| 종류      | 정의                                                                    |
| --------- | ----------------------------------------------------------------------- |
| 동적 매핑 | 처음 색인되는 문서를 바탕으로 매핑 정보를 ElasticSearch가 동적으로 생성 |
| 정적 매핑 | 문서의 매핑 정보를 미리 정의                                            |
|           |                                                                         |

> 매핑정보가 생성된 후 타입이 불일치하는 경우 파싱 에러가 발생한다. 

정적 매핑은 문서의 필드들이 가지는 값에 따라 타입을 지정해 줄 필요가 있을때 사용에 이점이 있다.
> [! example]
> 특정 타입의 최대 값을 넘는 값이 들어갈 경우가 있으면 반드시 더 큰 타입으로 지정해줄 필요가 있다.
> 불필요한 색인을 막기 위해 -> 텍스트 필드에 따라 자동으로 생성되는 keyword가 불필요하다면 정적 매핑으로 지정.



# 색인
문서를 분석하고 저장하는 과정

![[IMG_3537.jpg]]

클러스터에 데이터 노드가 추가된 경우에 샤드의 개수가 유지된다면 각 노드에 샤드 개수가 고르게 분배되지 않기 때문에 용량 불균형이 일어날 수 있다.

#### 색인 성능에 문제가 있다면? 
> 클러스터로서의 이점을 살리고 있는지를 먼저 살펴 봐야 한다.
> 예) 노드의 cpu 사용률이 낮다면 샤드를 더 추가해서 성능을 더 끌어올린다.


# 검색

검색어 분석 -> inverted index 검색 -> 검색 결과 표시

#### inverted index
문자열을 분석한 결과를 저장하고 있는 구조체

#### analyzer

text -> character filter -> tokenizer -> token filter -> tokens

문자열을 분석해서 inverted index 구성을 위한 토큰을 만들어 내는 과정

character filter, tokenizer, token filter로 애널라이저를 구성한다.


1. 검색어 분석 == 애널라이저 적용
2. inverted index 검색 == 생성된 토큰을 inverted index에서 검색
3. 검색결과 표시

검색 요청은 프라이머리, 레플리카 샤드 모두가 처리할 수 있다.

number_of_replicas는 dynamic하기때문에 운영중에 동적으로 레플리카 수를 변경하여 검색 성능을 높일 수 있다.

# text, keyword타입
둘 다 문자열을 나타내기 위한 타입이다.

text 타입은 full-text serach를 위해 토큰이 생성된다.
keyword타입은 exact matching을 위해 토큰이 생성된다.

``` text
i am software engineer
text type : i, am, software, engineer
keyword: i am software engineer
```

keyword 타입이 text 타입에 비해 cpu를 덜 사용하기 때문에 색인 속도가 더 빠르다.

문자열 필드가 동적 매핑이 되면 text, keyword타입 둘 다 생성된다.
> 즉, 문자열 특성에 따라 text, keyword를 정적 매핑해주면 성능에 도움이 된다.

| text에 적합할만한 필드          | keyword에 적합할만한 필드 |
| ------------------------------- | ------------------------- |
| 주소, 이름, 물품 상세 정보, etc | 성별, 물품 카테고리, etc  |
|                                 |                           |


[[elastic search monitoring]]